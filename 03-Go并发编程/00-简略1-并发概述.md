## 一 并发编程历史  

在早期的操作系统中，任务是一个接着一个运行的，各个任务的执行完全是串行的，只有在一个任务运行完成之后，另一个任务才会被读取。  

并发的主要思想是使多个任务可以在同一个时间内执行以便更快的得到结果。其思想来自于多任务操作系统(允许同时运行多个程序)，当一个程序暂时不需要使用CPU的时候，系统会把该程序挂起或中断，以使其他程序可以使用CPU。  

对并发的支持从汇编语言开始就存在了，只不过这样会引起对系统资源的无限制抢夺，造成死锁，上古语言在并发编程方面极其不便。  

## 二 串行与并发

#### 2.1 并发理论基础

串行与并发区别：
- 串行程序：只能被顺序执行的指令列表
- 并发程序：可以被并发执行的两个及两个以上的串行程序的综合体

并发程序能够得以执行，依赖于两个要素：
- 多元程序：并发程序内部的串行程序被允许运行在一个或者多个可共享的CPU上（1968年荷兰图领奖得住提出的多个串行程序复用多个CPU的方法）
- 多元处理：并发程序内部的串行程序也被允许运行在专为他服务的CPU上（1980年美国计算机学家提出的多个CPU使用同一个内存，且在同一时刻可能会有数个串行程序分别运行在不同的CPU上）

#### 2.2 并发与并行

并发与并行区别：
- 并发程序：可以被同时发起的执行程序，是个宽泛的概念，规定时间内多个请求都得到执行和处理，强调的是给外界的感觉，实际上内部可能是分时操作的。并发重在避免阻塞，使程序不会因为一个阻塞而停止。
- 并行程序：可以在并行的硬件上执行的并发程序。将每一个任务分配给一个处理器独立完成，同一时间点，任务同时运行，最简单的并行就是多机，多台机器并行处理。 

二者概念的区别是是否同时执行，比如吃饭时，电话来了，需要停止吃饭去接电话，接完电话继续吃饭，这是并发执行，但是吃饭时电话来了，边吃边接是并行。  

程序与程序之间通过协商一致的协议进行通信，可以统一看做是一个系统，即并发系统。并发系统更有可能是并行的，因为其中的多个程序一般可以同时在不同的硬件环境上运行，因此并发系统也通常称为并行系统，即分布式系统。 

#### 2.3 并发解决方案

- 多进程:在操作系统层面并发，由于由系统内核管理，操作简单、进程互不影响，但是开销最大，占用资源较多，能开启的进程数也比较少，
- 多线程:多线程在大部分系统上仍然属于系统层面的并发，开销较大，且会存在死锁管理问题。
- 非阻塞IO:基于回调的异步非阻塞IO，尽可能少的运用线程，见Node.js
- 协程:本质上是用户态线程，不需要系统进行抢占式调度，且真正的实现寄存于线程中，开销极小。

#### 2.3 并发程序的内部交互

并发程序内部会被划分为多个部分，每个部分都可以看作为一个串行程序，不同的串行程序之间，可能存在交互的需求，比如常见的多个串行程序可能都要访问同一个资源，或者彼此间需要传递数据。此时我们就需要协调它们的执行，这就涉及了同步。  

同步的作用是避免在并发访问共享资源时可能发生的冲突。  

根据同步原则，程序如果想使用一个共享数据，就必须先请求该资源并获取到堆它的访问权，当程序不再需要某个资源的时，它应该放弃对该资源的访问权(即：释放资源)。一个程序对资源的请求不应该导致其他正在访问该资源的程序中断，而应该等到那个程序释放资源之后再进行请求。  

也就是说：在同一时刻，某个资源应该只被一个程序占用。  

传递数据是并发程序内部的另一种交互方式，也称为并发程序内部的通信。协调这种内部通信的方式不只同步一种，也可以使用异步方式对通信进行管理。这种方式可以使数据不加延迟的发送给数据接收方。即使数据接收方还没有为接收数据做好准备，也不会造成数据发送方的等待。数据会被临时存储在一个称谓通信缓存的数据结构中。  

通信缓存是一种特殊的数据结构，可以同时被多个程序使用，数据接收方可以在准备就绪之后按照数据存入通信缓存的顺序接收它们。  

## 三 进程 线程 协程

#### 3.1 进程

在操作系统运行过程中，可以产生很多进程，在unix/linux系统中，正常情况下，子进程是通过父进程fork创建的，子进程再创建新的进程。父进程无法预测子进程到底什么时候结束，当一个进程完成它的工作终止后，它的父进程需要调用系统取得子进程的终止态。  

多进程容易产生的问题：  

孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，其父进程变成了系统最开始的init进程，称为init进程领养孤儿进程。  

僵尸进程：进程终止，父进程尚未回收，子进程残留资源（PCB）于内核中，变成僵尸进程。

#### 3.2 线程

注意：在win下只有线程。
线程是Linux为了模仿，基于进程开启的轻量级进程，与进程一样拥有独立的PCB，但是没有独立的地址空间，地址空间是共享的。  

共享地址空间：
![](../images/Golang/thread-01.png)

如图得出：
- 线程：系统最小的执行单位，即cpu分配时间轮片的对象
- 进程：系统最小的资源分配单位

线程同步：同步即按预定的先后次序运行，线程发出某一个功能调用时，在没有得到结果之前，该调用不返回，且其他线程为保证数据一致性，不能调用该功能。线程同步是为了避免引起数据混乱，解决与时间有关的错误，实际上，进程，线程，信号之间都需要同步机制。 

总结：多个控制流，共同操作一个共享资源，都需要同步。

#### 3.3 协程

协程：协程的优势在于其轻量级，可以轻松创建上百万个协程而不会造成系统资源衰竭。  

线程需要上下文不停切换，协程不会主动交出使用权，除非代码中主动要求切换，或者发生IO。（主动切换函数：runtime.Gosched）  

这样如果没有主动切换、IO，那么协程一直运行下去，遇到IO，则立即切换到被的协程，很好的解决了并发编程。   
